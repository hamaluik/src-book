//! Source repository metadata and file discovery.
//!
//! This module handles loading files from a git repository, extracting commit history,
//! and managing author information. The `Source` struct is the central data structure
//! that gets passed to the PDF renderer.

mod author;
mod commit;
mod tag;
use std::collections::HashMap;
use std::path::PathBuf;

pub use author::*;
pub use commit::*;
pub use tag::*;

mod providers;
use anyhow::{anyhow, Context, Result};
pub use providers::*;
use serde::{Deserialize, Serialize};

/// Source metadata and file list for rendering a codebase as a book.
///
/// Created by the config wizard or loaded from `src-book.toml`. The `source_files` list
/// is pre-sorted based on the optional `entrypoint` to ensure logical reading order.
///
/// Field order matters for TOML serialization: simple values must come before arrays/tables.
#[derive(Default, Debug, Serialize, Deserialize)]
pub struct Source {
    /// Book title displayed on the title page
    pub title: Option<String>,

    /// Path to the git repository root
    pub repository: PathBuf,

    /// Glob patterns to exclude from the source file list (e.g., "*.generated.rs").
    /// Stored in config so the `update` command can re-apply the same filters when
    /// refreshing file lists.
    #[serde(default)]
    pub block_globs: Vec<String>,

    /// Whether to exclude files in git submodule directories.
    /// Submodules often contain external dependencies that would bloat the book.
    /// Stored in config so the `update` command respects the original choice.
    #[serde(default)]
    pub exclude_submodules: bool,

    /// Optional entrypoint file (e.g., `src/main.rs`) that controls file ordering.
    /// When set, the entrypoint appears first, followed by sibling files in its directory,
    /// then subdirectories, then everything else. Helps readers start at the logical entry
    /// point and follow imports naturally.
    /// Empty string means no entrypoint.
    #[serde(default)]
    pub entrypoint: String,

    /// Controls commit history ordering in the generated book.
    #[serde(default)]
    pub commit_order: CommitOrder,

    /// SPDX licence identifiers (e.g., "MIT", "Apache-2.0"). Not validated by default.
    #[serde(default)]
    pub licences: Vec<String>,

    /// Documentation and metadata files that appear before source code.
    /// Includes files like README, ARCHITECTURE, CONTRIBUTING, Cargo.toml, and LICENSE.
    /// Rendered in their own "Frontmatter" section with a flat (non-hierarchical) TOC listing.
    #[serde(default)]
    pub frontmatter_files: Vec<PathBuf>,

    /// Source files to include in the book, in display order.
    /// Generated by walking the repository (respecting .gitignore) and sorted by the
    /// entrypoint-aware algorithm if an entrypoint is specified.
    #[serde(default)]
    pub source_files: Vec<PathBuf>,

    /// Repository authors extracted from git commit history.
    /// Sorted by prominence (commit count) at render time.
    #[serde(default)]
    pub authors: Vec<Author>,

    // Legacy field name (read for migration, not written)
    #[serde(default, skip_serializing)]
    pub(crate) licenses: Vec<String>,
}

impl Source {
    /// Returns the entrypoint as a PathBuf, if configured.
    pub fn entrypoint_path(&self) -> Option<PathBuf> {
        if self.entrypoint.is_empty() {
            None
        } else {
            Some(PathBuf::from(&self.entrypoint))
        }
    }

    /// Applies legacy field values to their new locations.
    /// Called after deserialization to migrate old config formats.
    pub fn apply_legacy_fields(&mut self) {
        // migrate licenses -> licences
        if !self.licenses.is_empty() && self.licences.is_empty() {
            self.licences = std::mem::take(&mut self.licenses);
        }
    }

    /// Load commits from the repository, ordered according to `commit_order`.
    ///
    /// Returns an empty list if `commit_order` is `Disabled`.
    pub fn commits(&self) -> Result<Vec<Commit>> {
        if self.commit_order == CommitOrder::Disabled {
            return Ok(Vec::new());
        }

        let repo = git2::Repository::open(&self.repository).with_context(|| {
            format!(
                "Failed to open path {} as a git repository!",
                self.repository.display()
            )
        })?;

        let mut walk = repo
            .revwalk()
            .with_context(|| "Failed to start walking the repository")?;
        let head = repo
            .head()
            .with_context(|| "Failed to get the repository HEAD")?;
        let head_oid = head
            .resolve()
            .with_context(|| "Failed to resolve HEAD reference")?
            .target()
            .ok_or(anyhow!("HEAD doesn't have an OID reference"))?;
        walk.push(head_oid)
            .with_context(|| "Failed to push head OID to revwalk")?;

        let mut commits: Vec<Commit> = Vec::default();

        for oid in walk {
            let oid = oid.with_context(|| "Failed to get OID while walking repository")?;
            let commit = repo
                .find_commit(oid)
                .with_context(|| format!("Failed to find commit for OID {}", oid))?;

            let commit = Commit::from(&commit);
            commits.push(commit);
        }

        // git2 revwalk returns newest first by default
        if self.commit_order == CommitOrder::OldestFirst {
            commits.reverse();
        }

        Ok(commits)
    }

    /// Load tags from the repository, sorted according to the specified order.
    pub fn tags(&self, order: TagOrder) -> Result<Vec<Tag>> {
        let repo = git2::Repository::open(&self.repository).with_context(|| {
            format!(
                "Failed to open path {} as a git repository!",
                self.repository.display()
            )
        })?;

        let mut tags: Vec<Tag> = Vec::new();

        // iterate all references and filter for tags
        for reference in repo.references()? {
            let reference = reference?;
            if reference.is_tag() {
                if let Some(tag) = Tag::from_ref(&reference, &repo) {
                    tags.push(tag);
                }
            }
        }

        Tag::sort_tags(&mut tags, order);
        Ok(tags)
    }

    /// Build a map from commit hash to list of tag names pointing to that commit.
    ///
    /// Used for inline tag display in the commit history section.
    pub fn tags_by_commit(&self) -> Result<HashMap<String, Vec<String>>> {
        let repo = git2::Repository::open(&self.repository).with_context(|| {
            format!(
                "Failed to open path {} as a git repository!",
                self.repository.display()
            )
        })?;

        let mut map: HashMap<String, Vec<String>> = HashMap::new();

        for reference in repo.references()? {
            let reference = reference?;
            if reference.is_tag() {
                if let Some(tag) = Tag::from_ref(&reference, &repo) {
                    map.entry(tag.commit_hash.clone())
                        .or_default()
                        .push(tag.name.clone());
                }
            }
        }

        // sort tag names within each commit for consistent display
        for tags in map.values_mut() {
            tags.sort();
        }

        Ok(map)
    }
}
