//! Source repository metadata and file discovery.
//!
//! This module handles loading files from a git repository, extracting commit history,
//! and managing author information. The `Source` struct is the central data structure
//! that gets passed to the PDF renderer.

mod author;
mod commit;
use std::path::PathBuf;

pub use author::*;
pub use commit::*;

mod providers;
pub use providers::*;
use anyhow::{anyhow, Context, Result};
use serde::{Deserialize, Serialize};

/// Source metadata and file list for rendering a codebase as a book.
///
/// Created by the config wizard or loaded from `src-book.toml`. The `source_files` list
/// is pre-sorted based on the optional `entrypoint` to ensure logical reading order.
///
/// Field order matters for TOML serialization: simple values must come before arrays/tables.
#[derive(Default, Debug, Serialize, Deserialize)]
pub struct Source {
    /// Book title displayed on the title page
    pub title: Option<String>,

    /// Path to the git repository root
    pub repository: PathBuf,

    /// Optional entrypoint file (e.g., `src/main.rs`) that controls file ordering.
    /// When set, the entrypoint appears first, followed by sibling files in its directory,
    /// then subdirectories, then everything else. Helps readers start at the logical entry
    /// point and follow imports naturally.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub entrypoint: Option<PathBuf>,

    /// Controls commit history ordering in the generated book.
    #[serde(default)]
    pub commit_order: CommitOrder,

    /// SPDX licence identifiers (e.g., "MIT", "Apache-2.0"). Not validated by default.
    pub licenses: Vec<String>,

    /// Source files to include in the book, in display order.
    /// Generated by walking the repository (respecting .gitignore) and sorted by the
    /// entrypoint-aware algorithm if an entrypoint is specified.
    pub source_files: Vec<PathBuf>,

    /// Repository authors extracted from git commit history.
    /// Sorted by prominence (commit count) at render time.
    pub authors: Vec<Author>,
}

impl Source {
    /// Load commits from the repository, ordered according to `commit_order`.
    ///
    /// Returns an empty list if `commit_order` is `Disabled`.
    pub fn commits(&self) -> Result<Vec<Commit>> {
        if self.commit_order == CommitOrder::Disabled {
            return Ok(Vec::new());
        }

        let repo = git2::Repository::open(&self.repository).with_context(|| {
            format!(
                "Failed to open path {} as a git repository!",
                self.repository.display()
            )
        })?;

        let mut walk = repo
            .revwalk()
            .with_context(|| "Failed to start walking the repository")?;
        let head = repo
            .head()
            .with_context(|| "Failed to get the repository HEAD")?;
        let head_oid = head
            .resolve()
            .with_context(|| "Failed to resolve HEAD reference")?
            .target()
            .ok_or(anyhow!("HEAD doesn't have an OID reference"))?;
        walk.push(head_oid)
            .with_context(|| "Failed to push head OID to revwalk")?;

        let mut commits: Vec<Commit> = Vec::default();

        for oid in walk.into_iter() {
            let oid = oid.with_context(|| "Failed to get OID while walking repository")?;
            let commit = repo
                .find_commit(oid)
                .with_context(|| format!("Failed to find commit for OID {}", oid))?;

            let commit = Commit::from(&commit);
            commits.push(commit);
        }

        // git2 revwalk returns newest first by default
        if self.commit_order == CommitOrder::OldestFirst {
            commits.reverse();
        }

        Ok(commits)
    }
}
